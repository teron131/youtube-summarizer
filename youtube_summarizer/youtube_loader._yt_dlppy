"""
YouTube Video and Audio Loader
----------------------

This module provides robust functions to extract information and content from YouTube videos, including video details, subtitles, and audio streams. It uses `yt-dlp` with multiple strategies to ensure reliable and efficient data extraction, especially in cloud environments like Railway.
"""

import os
from typing import Any, Dict

import requests
import yt_dlp

from .summarizer import simple_format_subtitle
from .transcriber import optimize_audio_for_transcription, transcribe_with_fal
from .utils import log_and_print, parse_youtube_json_captions, s2hk, srt_to_txt


def extract_video_metadata(info: Dict[str, Any]) -> Dict[str, Any]:
    """Extract relevant video metadata from yt-dlp info."""
    duration = info.get("duration")
    if duration:
        minutes, seconds = divmod(duration, 60)
        duration_str = f"{int(minutes):02d}:{int(seconds):02d}"
    else:
        duration_str = None

    return {
        "title": info.get("title", "Unknown Title"),
        "author": info.get("uploader", "Unknown Author"),
        "duration": duration_str,
        "thumbnail": info.get("thumbnail"),
        "view_count": info.get("view_count"),
        "upload_date": info.get("upload_date"),
    }


def extract_video_info(url: str) -> Dict[str, Any]:
    """
    Extract video information using robust strategies optimized for external environments.

    This function implements a multi-tier approach:
    1. Try standard extraction with enhanced anti-detection
    2. Fall back to alternative extraction methods
    3. Provide detailed error reporting for debugging
    """
    log_and_print("📋 Extracting video info...")

    # Method 1: Standard extraction with enhanced anti-detection
    try:
        log_and_print("🔄 Attempt 1: Standard extraction...")

        ydl_opts = {
            "quiet": True,
            "no_warnings": True,
            "extract_flat": False,
            "forcejson": True,
            "socket_timeout": 90,
            "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "referer": "https://www.youtube.com/",
            "http_headers": {
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
                "Accept-Language": "en-US,en;q=0.9",
                "Accept-Encoding": "gzip, deflate, br",
                "DNT": "1",
                "Connection": "keep-alive",
                "Upgrade-Insecure-Requests": "1",
            },
            # Enhanced anti-detection
            "nocheckcertificate": True,
            "ignoreerrors": False,
            "no_color": True,
            "retries": 3,
            "fragment_retries": 3,
            "extractor_retries": 3,
            # Format selection
            "format": "bestaudio/best",
            "prefer_ffmpeg": True,
            "keepvideo": False,
            # Geographic and network settings
            "geo_bypass": True,
            "geo_bypass_country": "US",
        }

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            result = ydl.extract_info(url, download=False)
            log_and_print("✅ Standard extraction succeeded!")
            return result

    except Exception as e:
        log_and_print(f"❌ Standard extraction failed: {str(e)}")

    # Method 2: Alternative extraction with different client
    try:
        log_and_print("🔄 Attempt 2: Alternative client method...")

        ydl_opts = {
            "quiet": True,
            "no_warnings": True,
            "format": "bestaudio/best",
            "extractor_args": {
                "youtube": {
                    "player_client": ["tv_embedded", "web"],
                    "player_skip": ["webpage"],
                }
            },
            "user_agent": "Mozilla/5.0 (SMART-TV; LINUX; Tizen 6.0) AppleWebKit/537.36",
            "referer": "https://www.youtube.com/",
            "nocheckcertificate": True,
            "retries": 2,
        }

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            result = ydl.extract_info(url, download=False)
            log_and_print("✅ Alternative client method succeeded!")
            return result

    except Exception as e:
        log_and_print(f"❌ Alternative client method failed: {str(e)}")

    # Method 3: Minimal configuration as last resort
    try:
        log_and_print("🔄 Attempt 3: Minimal configuration...")

        ydl_opts = {
            "quiet": True,
            "no_warnings": True,
            "format": "bestaudio/best",
            "extract_flat": False,
            "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        }

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            result = ydl.extract_info(url, download=False)
            log_and_print("✅ Minimal configuration succeeded!")
            return result

    except Exception as e:
        log_and_print(f"❌ Minimal configuration failed: {str(e)}")

    # All methods failed
    error_msg = f"""
YouTube extraction completely failed. This may be due to:
1. YouTube's aggressive bot detection
2. Geographic restrictions
3. Video privacy settings
4. Network connectivity issues

Suggestions:
- Try again in a few minutes
- Use a different network/VPN
- Try a different video
- Check if the video is available in your region
"""
    log_and_print(f"💔 Complete extraction failure: {error_msg}")
    raise RuntimeError(error_msg.strip())


def get_subtitle_from_captions(info: Dict[str, Any]) -> str | None:
    """
    Extracts and formats existing subtitles from video info.

    Prioritizes Chinese (Traditional/Simplified) and English subtitles.
    """
    subtitles = info.get("subtitles", {})
    for lang in ["zh-HK", "zh-CN", "en"]:
        if lang in subtitles:
            subtitle_info = subtitles[lang][0]
            response = requests.get(subtitle_info["url"])
            raw_content = response.text

            if lang == "zh-CN":
                raw_content = s2hk(raw_content)

            if raw_content.strip().startswith("{"):
                return parse_youtube_json_captions(raw_content)
            else:
                return srt_to_txt(raw_content)
    return None


def download_audio_bytes(info: Dict[str, Any]) -> bytes:
    """
    Downloads audio from YouTube video info with optimized format selection for size.

    Selects the most efficient audio-only format (Opus, AAC) to minimize download size
    and processing time.
    """
    formats = info.get("formats", [])
    high_efficiency_formats = []
    medium_efficiency_formats = []
    fallback_formats = []

    for fmt in formats:
        if fmt.get("vcodec") == "none" and fmt.get("acodec") != "none":
            acodec = fmt.get("acodec", "").lower()
            filesize = fmt.get("filesize", 0) or fmt.get("filesize_approx", 0) or 0
            if any(codec in acodec for codec in ["opus"]):
                high_efficiency_formats.append((fmt, filesize))
            elif any(codec in acodec for codec in ["aac", "mp4a"]):
                medium_efficiency_formats.append((fmt, filesize))
            else:
                fallback_formats.append((fmt, filesize))
        elif fmt.get("acodec") != "none":
            filesize = fmt.get("filesize", 0) or fmt.get("filesize_approx", 0) or 0
            fallback_formats.append((fmt, filesize))

    high_efficiency_formats.sort(key=lambda x: x[1] if x[1] > 0 else float("inf"))
    medium_efficiency_formats.sort(key=lambda x: x[1] if x[1] > 0 else float("inf"))
    fallback_formats.sort(key=lambda x: x[1] if x[1] > 0 else float("inf"))

    audio_format = None
    selected_from = "unknown"

    for fmt_list, category in [
        (high_efficiency_formats, "high_efficiency"),
        (medium_efficiency_formats, "medium_efficiency"),
        (fallback_formats, "fallback"),
    ]:
        if fmt_list:
            audio_format, _ = fmt_list[0]
            selected_from = category
            break

    if not audio_format:
        all_formats = [fmt for fmt_list in [high_efficiency_formats, medium_efficiency_formats, fallback_formats] for fmt, _ in fmt_list]
        if all_formats:
            audio_format = all_formats[0]
            selected_from = "any_available"
        else:
            raise RuntimeError("No audio format available")

    filesize_mb = (audio_format.get("filesize") or audio_format.get("filesize_approx") or 0) / 1024 / 1024
    log_and_print(f"Selected format: {audio_format.get('format_id')} ({selected_from}) - {audio_format.get('acodec')} - {filesize_mb:.1f}MB estimated")

    audio_url = audio_format["url"]
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Referer": "https://www.youtube.com/",
    }

    try:
        response = requests.get(audio_url, headers=headers, stream=True, timeout=60)
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        if "403" in str(e):
            raise RuntimeError("YouTube blocked audio download (HTTP 403). Try again later or use a different video.")
        else:
            raise RuntimeError(f"Failed to download audio: {e}")

    audio_data = b""
    for chunk in response.iter_content(chunk_size=32768):
        if chunk:
            audio_data += chunk

    log_and_print(f"Downloaded {len(audio_data)} bytes of audio")
    return audio_data


def transcribe_youtube_video(info: Dict[str, Any]) -> str:
    """
    Complete transcription workflow for YouTube videos.

    This function handles the entire process:
    1. Download audio from video info
    2. Optimize audio for transcription
    3. Transcribe using FAL API
    4. Format and return the transcript

    Args:
        info: Video info dictionary from extract_video_info()

    Returns:
        Formatted transcript string

    Raises:
        RuntimeError: If FAL_KEY is not configured or transcription fails
    """

    # Check if FAL API key is configured
    if not os.getenv("FAL_KEY"):
        raise RuntimeError("FAL_KEY not configured - please set your FAL API key")

    log_and_print("📋 Step 1: Downloading audio...")
    audio_bytes = download_audio_bytes(info)

    log_and_print("📋 Step 2: Optimizing audio for transcription...")
    optimized_audio = optimize_audio_for_transcription(audio_bytes)

    log_and_print("📋 Step 3: Transcribing audio with FAL API...")
    subtitle = transcribe_with_fal(optimized_audio)

    log_and_print("📋 Step 4: Formatting transcript...")
    formatted_subtitle = simple_format_subtitle(subtitle)

    log_and_print("✅ Transcription completed successfully")
    return formatted_subtitle


def get_video_transcript(url: str) -> str:
    """
    Get video transcript with fallback to existing captions.

    This function first checks for existing captions, and if none are found,
    proceeds with audio download and transcription.

    Args:
        url: YouTube video URL

    Returns:
        Formatted transcript string
    """
    # Extract video info first
    info = extract_video_info(url)

    # Check for existing captions
    subtitle = get_subtitle_from_captions(info)

    if subtitle:
        log_and_print("✅ Found existing captions - using them")
        return simple_format_subtitle(subtitle)
    else:
        log_and_print("🎯 No captions found - proceeding with transcription")
        return transcribe_youtube_video(info)
